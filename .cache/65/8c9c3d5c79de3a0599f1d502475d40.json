{"id":"../node_modules/react-query/dist/react-query.mjs","dependencies":[{"name":"/Users/kingrayhan/projects/dokan/accounts/package.json","includedInParent":true,"mtime":1597834049000},{"name":"/Users/kingrayhan/projects/dokan/accounts/.babelrc","includedInParent":true,"mtime":1597769324000},{"name":"/Users/kingrayhan/projects/dokan/accounts/node_modules/react-query/package.json","includedInParent":true,"mtime":1597733547000},{"name":"react","loc":{"line":1,"column":18},"parent":"/Users/kingrayhan/projects/dokan/accounts/node_modules/react-query/dist/react-query.mjs","resolved":"/Users/kingrayhan/projects/dokan/accounts/node_modules/react/index.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deepIncludes = deepIncludes;\nexports.makeQueryCache = makeQueryCache;\nexports.setConsole = setConsole;\nexports.setFocusHandler = setFocusHandler;\nexports.stableStringify = stableStringify;\nexports.useInfiniteQuery = useInfiniteQuery;\nexports.useIsFetching = useIsFetching;\nexports.useMutation = useMutation;\nexports.usePaginatedQuery = usePaginatedQuery;\nexports.useQuery = useQuery;\nexports.useQueryCache = exports.queryCaches = exports.queryCache = exports.ReactQueryConfigProvider = exports.ReactQueryCacheProvider = exports.QueryStatus = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n} // The tuple variants are only to infer types in the public API\n\n\nvar QueryStatus;\nexports.QueryStatus = QueryStatus;\n\n(function (QueryStatus) {\n  QueryStatus[\"Idle\"] = \"idle\";\n  QueryStatus[\"Loading\"] = \"loading\";\n  QueryStatus[\"Error\"] = \"error\";\n  QueryStatus[\"Success\"] = \"success\";\n})(QueryStatus || (exports.QueryStatus = QueryStatus = {})); // UTILS\n\n\nvar _uid = 0;\n\nvar uid = function uid() {\n  return _uid++;\n};\n\nvar cancelledError = {};\nvar isServer = typeof window === 'undefined';\n\nfunction noop() {\n  return void 0;\n}\n\nfunction identity(d) {\n  return d;\n}\n\nvar Console = console || {\n  error: noop,\n  warn: noop,\n  log: noop\n};\n\nfunction setConsole(c) {\n  Console = c;\n}\n\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\n\nfunction stableStringifyReplacer(_key, value) {\n  if (typeof value === 'function') {\n    throw new Error('Cannot stringify non JSON value');\n  }\n\n  if (isObject(value)) {\n    return Object.keys(value).sort().reduce(function (result, key) {\n      result[key] = value[key];\n      return result;\n    }, {});\n  }\n\n  return value;\n}\n\nfunction stableStringify(value) {\n  return JSON.stringify(value, stableStringifyReplacer);\n}\n\nfunction isObject(a) {\n  return a && typeof a === 'object' && !Array.isArray(a);\n}\n\nfunction deepIncludes(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(function (key) {\n      return !deepIncludes(a[key], b[key]);\n    });\n  }\n\n  return false;\n}\n\nfunction isDocumentVisible() {\n  // document global can be unavailable in react native\n  if (typeof document === 'undefined') {\n    return true;\n  }\n\n  return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n}\n\nfunction isOnline() {\n  return navigator.onLine === undefined || navigator.onLine;\n}\n\nfunction getQueryArgs(args) {\n  var queryKey;\n  var queryFn;\n  var config;\n  var options;\n\n  if (isObject(args[0])) {\n    queryKey = args[0].queryKey;\n    queryFn = args[0].queryFn;\n    config = args[0].config;\n    options = args[1];\n  } else if (isObject(args[1])) {\n    queryKey = args[0];\n    config = args[1];\n    options = args[2];\n  } else {\n    queryKey = args[0];\n    queryFn = args[1];\n    config = args[2];\n    options = args[3];\n  }\n\n  config = config || {};\n\n  if (queryFn) {\n    config = _extends({}, config, {\n      queryFn: queryFn\n    });\n  }\n\n  return [queryKey, config, options];\n}\n\nfunction deepEqual(a, b) {\n  return equal(a, b, true);\n}\n\nfunction shallowEqual(a, b) {\n  return equal(a, b, false);\n} // This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.\n// The parts for comparing any non-JSON-supported values has been removed\n\n\nfunction equal(a, b, deep, depth) {\n  if (depth === void 0) {\n    depth = 0;\n  }\n\n  if (a === b) return true;\n\n  if ((deep || !depth) && a && b && typeof a == 'object' && typeof b == 'object') {\n    var length, i;\n\n    if (Array.isArray(a)) {\n      length = a.length; // eslint-disable-next-line eqeqeq\n\n      if (length != b.length) return false;\n\n      for (i = length; i-- !== 0;) {\n        if (!equal(a[i], b[i], deep, depth + 1)) return false;\n      }\n\n      return true;\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    var keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;) {\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    }\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n      if (!equal(a[key], b[key], deep, depth + 1)) return false;\n    }\n\n    return true;\n  } // true if both NaN, false otherwise\n  // eslint-disable-next-line no-self-compare\n\n\n  return a !== a && b !== b;\n}\n\nfunction getStatusProps(status) {\n  return {\n    status: status,\n    isLoading: status === QueryStatus.Loading,\n    isSuccess: status === QueryStatus.Success,\n    isError: status === QueryStatus.Error,\n    isIdle: status === QueryStatus.Idle\n  };\n} // CONFIG\n\n\nvar defaultQueryKeySerializerFn = function defaultQueryKeySerializerFn(queryKey) {\n  try {\n    var arrayQueryKey = Array.isArray(queryKey) ? queryKey : [queryKey];\n    var queryHash = stableStringify(arrayQueryKey);\n    arrayQueryKey = JSON.parse(queryHash);\n    return [queryHash, arrayQueryKey];\n  } catch (_unused) {\n    throw new Error('A valid query key is required!');\n  }\n};\n\nvar DEFAULT_CONFIG = {\n  shared: {\n    suspense: false\n  },\n  queries: {\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n    enabled: true,\n    retry: 3,\n    retryDelay: function retryDelay(attemptIndex) {\n      return Math.min(1000 * Math.pow(2, attemptIndex), 30000);\n    },\n    staleTime: 0,\n    cacheTime: 5 * 60 * 1000,\n    refetchOnWindowFocus: true,\n    refetchInterval: false,\n    queryFnParamsFilter: identity,\n    refetchOnMount: true,\n    isDataEqual: deepEqual,\n    useErrorBoundary: false\n  },\n  mutations: {\n    throwOnError: false,\n    useErrorBoundary: false\n  }\n};\nvar defaultConfigRef = {\n  current: DEFAULT_CONFIG\n}; // CLASS\n\nfunction _empty() {}\n\nfunction _awaitIgnored(value, direct) {\n  if (!direct) {\n    return value && value.then ? value.then(_empty) : Promise.resolve();\n  }\n}\n\nfunction _invokeIgnored(body) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(_empty);\n  }\n}\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _continueIgnored(value) {\n  if (value && value.then) {\n    return value.then(_empty);\n  }\n}\n\nvar QueryInstance = /*#__PURE__*/function () {\n  function QueryInstance(query, onStateUpdate) {\n    this.id = uid();\n    this.stateUpdateListener = onStateUpdate;\n    this.query = query;\n    this.config = {};\n  }\n\n  var _proto = QueryInstance.prototype;\n\n  _proto.clearInterval = function (_clearInterval) {\n    function clearInterval() {\n      return _clearInterval.apply(this, arguments);\n    }\n\n    clearInterval.toString = function () {\n      return _clearInterval.toString();\n    };\n\n    return clearInterval;\n  }(function () {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  });\n\n  _proto.updateConfig = function updateConfig(config) {\n    var _this = this;\n\n    var oldConfig = this.config; // Update the config\n\n    this.config = config;\n\n    if (!isServer) {\n      if ((oldConfig == null ? void 0 : oldConfig.refetchInterval) === config.refetchInterval) {\n        return;\n      }\n\n      this.query.clearIntervals();\n      var minInterval = Math.min.apply(Math, this.query.instances.map(function (d) {\n        return d.config.refetchInterval || Infinity;\n      }));\n\n      if (!this.refetchIntervalId && minInterval > 0 && minInterval < Infinity) {\n        this.refetchIntervalId = setInterval(function () {\n          if (_this.query.instances.some(function (d) {\n            return d.config.enabled;\n          }) && (isDocumentVisible() || _this.query.instances.some(function (d) {\n            return d.config.refetchIntervalInBackground;\n          }))) {\n            _this.query.fetch();\n          }\n        }, minInterval);\n      }\n    }\n  };\n\n  _proto.run = function run() {\n    try {\n      var _this3 = this;\n\n      return _continueIgnored(_catch(function () {\n        // Perform the refetch for this query if necessary\n        return _invokeIgnored(function () {\n          if (_this3.query.instances.some(function (d) {\n            return d.config.enabled;\n          }) && // Don't auto refetch if disabled\n          !(_this3.config.suspense && _this3.query.state.isFetched) && // Don't refetch if in suspense mode and the data is already fetched\n          _this3.query.state.isStale && ( // Only refetch if stale\n          _this3.config.refetchOnMount || _this3.query.instances.length === 1)) {\n            return _awaitIgnored(_this3.query.fetch());\n          }\n        });\n      }, function (error) {\n        Console.error(error);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.unsubscribe = function unsubscribe(preventGC) {\n    var _this4 = this;\n\n    this.query.instances = this.query.instances.filter(function (d) {\n      return d.id !== _this4.id;\n    });\n\n    if (!this.query.instances.length) {\n      this.clearInterval();\n      this.query.cancel();\n\n      if (!preventGC && !isServer) {\n        // Schedule garbage collection\n        this.query.scheduleGarbageCollection();\n      }\n    }\n  };\n\n  _proto.onStateUpdate = function onStateUpdate(state, action) {\n    var _this$stateUpdateList;\n\n    if (action.type === ActionType.Success && state.isSuccess) {\n      var _this$config$onSucces, _this$config, _this$config$onSettle, _this$config2;\n\n      (_this$config$onSucces = (_this$config = this.config).onSuccess) == null ? void 0 : _this$config$onSucces.call(_this$config, state.data);\n      (_this$config$onSettle = (_this$config2 = this.config).onSettled) == null ? void 0 : _this$config$onSettle.call(_this$config2, state.data, null);\n    }\n\n    if (action.type === ActionType.Error && state.isError) {\n      var _this$config$onError, _this$config3, _this$config$onSettle2, _this$config4;\n\n      (_this$config$onError = (_this$config3 = this.config).onError) == null ? void 0 : _this$config$onError.call(_this$config3, state.error);\n      (_this$config$onSettle2 = (_this$config4 = this.config).onSettled) == null ? void 0 : _this$config$onSettle2.call(_this$config4, undefined, state.error);\n    }\n\n    (_this$stateUpdateList = this.stateUpdateListener) == null ? void 0 : _this$stateUpdateList.call(this, state);\n  };\n\n  return QueryInstance;\n}();\n\nfunction _empty$1() {}\n\nfunction _awaitIgnored$1(value, direct) {\n  if (!direct) {\n    return value && value.then ? value.then(_empty$1) : Promise.resolve();\n  }\n}\n\nfunction _catch$1(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _continueIgnored$1(value) {\n  if (value && value.then) {\n    return value.then(_empty$1);\n  }\n}\n\nfunction _await(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nfunction _invoke(body, then) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(then);\n  }\n\n  return then(result);\n}\n\nfunction _async(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nfunction _invokeIgnored$1(body) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(_empty$1);\n  }\n}\n\nfunction _settle(pact, state, value) {\n  if (!pact.s) {\n    if (value instanceof _Pact) {\n      if (value.s) {\n        if (state & 1) {\n          state = value.s;\n        }\n\n        value = value.v;\n      } else {\n        value.o = _settle.bind(null, pact, state);\n        return;\n      }\n    }\n\n    if (value && value.then) {\n      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n      return;\n    }\n\n    pact.s = state;\n    pact.v = value;\n    var observer = pact.o;\n\n    if (observer) {\n      observer(pact);\n    }\n  }\n}\n\nvar _Pact = /*#__PURE__*/function () {\n  function _Pact() {}\n\n  _Pact.prototype.then = function (onFulfilled, onRejected) {\n    var result = new _Pact();\n    var state = this.s;\n\n    if (state) {\n      var callback = state & 1 ? onFulfilled : onRejected;\n\n      if (callback) {\n        try {\n          _settle(result, 1, callback(this.v));\n        } catch (e) {\n          _settle(result, 2, e);\n        }\n\n        return result;\n      } else {\n        return this;\n      }\n    }\n\n    this.o = function (_this) {\n      try {\n        var value = _this.v;\n\n        if (_this.s & 1) {\n          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n        } else if (onRejected) {\n          _settle(result, 1, onRejected(value));\n        } else {\n          _settle(result, 2, value);\n        }\n      } catch (e) {\n        _settle(result, 2, e);\n      }\n    };\n\n    return result;\n  };\n\n  return _Pact;\n}();\n\nfunction _isSettledPact(thenable) {\n  return thenable instanceof _Pact && thenable.s & 1;\n}\n\nfunction _do(body, test) {\n  var awaitBody;\n\n  do {\n    var result = body();\n\n    if (result && result.then) {\n      if (_isSettledPact(result)) {\n        result = result.v;\n      } else {\n        awaitBody = true;\n        break;\n      }\n    }\n\n    var shouldContinue = test();\n\n    if (_isSettledPact(shouldContinue)) {\n      shouldContinue = shouldContinue.v;\n    }\n\n    if (!shouldContinue) {\n      return result;\n    }\n  } while (!shouldContinue.then);\n\n  var pact = new _Pact();\n\n  var reject = _settle.bind(null, pact, 2);\n\n  (awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n  return pact;\n\n  function _resumeAfterBody(value) {\n    result = value;\n\n    for (;;) {\n      shouldContinue = test();\n\n      if (_isSettledPact(shouldContinue)) {\n        shouldContinue = shouldContinue.v;\n      }\n\n      if (!shouldContinue) {\n        break;\n      }\n\n      if (shouldContinue.then) {\n        shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n        return;\n      }\n\n      result = body();\n\n      if (result && result.then) {\n        if (_isSettledPact(result)) {\n          result = result.v;\n        } else {\n          result.then(_resumeAfterBody).then(void 0, reject);\n          return;\n        }\n      }\n    }\n\n    _settle(pact, 1, result);\n  }\n\n  function _resumeAfterTest(shouldContinue) {\n    if (shouldContinue) {\n      do {\n        result = body();\n\n        if (result && result.then) {\n          if (_isSettledPact(result)) {\n            result = result.v;\n          } else {\n            result.then(_resumeAfterBody).then(void 0, reject);\n            return;\n          }\n        }\n\n        shouldContinue = test();\n\n        if (_isSettledPact(shouldContinue)) {\n          shouldContinue = shouldContinue.v;\n        }\n\n        if (!shouldContinue) {\n          _settle(pact, 1, result);\n\n          return;\n        }\n      } while (!shouldContinue.then);\n\n      shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n    } else {\n      _settle(pact, 1, result);\n    }\n  }\n}\n\nfunction _continue(value, then) {\n  return value && value.then ? value.then(then) : then(value);\n}\n\nfunction _rethrow(thrown, value) {\n  if (thrown) throw value;\n  return value;\n}\n\nfunction _finallyRethrows(body, finalizer) {\n  try {\n    var result = body();\n  } catch (e) {\n    return finalizer(true, e);\n  }\n\n  if (result && result.then) {\n    return result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n  }\n\n  return finalizer(false, result);\n}\n\nvar ActionType;\n\n(function (ActionType) {\n  ActionType[\"Failed\"] = \"Failed\";\n  ActionType[\"MarkStale\"] = \"MarkStale\";\n  ActionType[\"Fetch\"] = \"Fetch\";\n  ActionType[\"Success\"] = \"Success\";\n  ActionType[\"Error\"] = \"Error\";\n  ActionType[\"SetState\"] = \"SetState\";\n})(ActionType || (ActionType = {})); // CLASS\n\n\nvar Query = /*#__PURE__*/function () {\n  function Query(init) {\n    this.config = init.config;\n    this.queryCache = init.queryCache;\n    this.queryKey = init.queryKey;\n    this.queryHash = init.queryHash;\n    this.notifyGlobalListeners = init.notifyGlobalListeners;\n    this.instances = [];\n    this.state = getDefaultState(init.config);\n\n    if (init.config.infinite) {\n      var infiniteConfig = init.config;\n      var infiniteData = this.state.data;\n\n      if (typeof infiniteData !== 'undefined' && typeof this.state.canFetchMore === 'undefined') {\n        this.fetchMoreVariable = infiniteConfig.getFetchMore(infiniteData[infiniteData.length - 1], infiniteData);\n        this.state.canFetchMore = Boolean(this.fetchMoreVariable);\n      } // Here we seed the pageVariables for the query\n\n\n      if (!this.pageVariables) {\n        this.pageVariables = [[].concat(this.queryKey)];\n      }\n    }\n  }\n\n  var _proto = Query.prototype;\n\n  _proto.dispatch = function dispatch(action) {\n    var newState = queryReducer(this.state, action); // Only update state if something has changed\n\n    if (!shallowEqual(this.state, newState)) {\n      this.state = newState;\n      this.instances.forEach(function (d) {\n        return d.onStateUpdate(newState, action);\n      });\n      this.notifyGlobalListeners(this);\n    }\n  };\n\n  _proto.scheduleStaleTimeout = function scheduleStaleTimeout() {\n    var _this = this;\n\n    if (isServer) {\n      return;\n    }\n\n    this.clearStaleTimeout();\n\n    if (this.state.isStale) {\n      return;\n    }\n\n    if (this.config.staleTime === Infinity) {\n      return;\n    }\n\n    this.staleTimeout = setTimeout(function () {\n      _this.invalidate();\n    }, this.config.staleTime);\n  };\n\n  _proto.invalidate = function invalidate() {\n    this.clearStaleTimeout();\n\n    if (!this.queryCache.queries[this.queryHash]) {\n      return;\n    }\n\n    if (this.state.isStale) {\n      return;\n    }\n\n    this.dispatch({\n      type: ActionType.MarkStale\n    });\n  };\n\n  _proto.scheduleGarbageCollection = function scheduleGarbageCollection() {\n    var _this2 = this;\n\n    this.clearCacheTimeout();\n\n    if (!this.queryCache.queries[this.queryHash]) {\n      return;\n    }\n\n    if (this.config.cacheTime === Infinity) {\n      return;\n    }\n\n    this.cacheTimeout = setTimeout(function () {\n      _this2.clear();\n    }, typeof this.state.data === 'undefined' && this.state.status !== QueryStatus.Error ? 0 : this.config.cacheTime);\n  };\n\n  _proto.refetch = function refetch() {\n    try {\n      var _this4 = this;\n\n      return _continueIgnored$1(_catch$1(function () {\n        return _awaitIgnored$1(_this4.fetch());\n      }, function (error) {\n        Console.error(error);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.heal = function heal() {\n    // Stop the query from being garbage collected\n    this.clearCacheTimeout(); // Mark the query as not cancelled\n\n    this.cancelled = null;\n  };\n\n  _proto.cancel = function cancel() {\n    this.cancelled = cancelledError;\n\n    if (this.cancelPromises) {\n      this.cancelPromises();\n    }\n\n    delete this.promise;\n  };\n\n  _proto.clearIntervals = function clearIntervals() {\n    this.instances.forEach(function (instance) {\n      instance.clearInterval();\n    });\n  };\n\n  _proto.clearStaleTimeout = function clearStaleTimeout() {\n    if (this.staleTimeout) {\n      clearTimeout(this.staleTimeout);\n      this.staleTimeout = undefined;\n    }\n  };\n\n  _proto.clearCacheTimeout = function clearCacheTimeout() {\n    if (this.cacheTimeout) {\n      clearTimeout(this.cacheTimeout);\n      this.cacheTimeout = undefined;\n    }\n  };\n\n  _proto.clearRetryTimeout = function clearRetryTimeout() {\n    if (this.retryTimeout) {\n      clearTimeout(this.retryTimeout);\n      this.retryTimeout = undefined;\n    }\n  };\n\n  _proto.setState = function setState(updater) {\n    this.dispatch({\n      type: ActionType.SetState,\n      updater: updater\n    });\n  };\n\n  _proto.setData = function setData(updater) {\n    var isStale = this.config.staleTime === 0; // Set data and mark it as cached\n\n    this.dispatch({\n      type: ActionType.Success,\n      updater: updater,\n      isStale: isStale\n    });\n\n    if (!isStale) {\n      // Schedule a fresh invalidation!\n      this.scheduleStaleTimeout();\n    }\n  };\n\n  _proto.clear = function clear() {\n    this.clearStaleTimeout();\n    this.clearCacheTimeout();\n    this.clearRetryTimeout();\n    this.clearIntervals();\n    this.cancel();\n    delete this.queryCache.queries[this.queryHash];\n    this.notifyGlobalListeners(this);\n  };\n\n  _proto.subscribe = function subscribe(onStateUpdate) {\n    var instance = new QueryInstance(this, onStateUpdate);\n    this.instances.push(instance);\n    this.heal();\n    return instance;\n  } // Set up the core fetcher function\n  ;\n\n  _proto.tryFetchData = function tryFetchData(fn, args) {\n    try {\n      var _this6 = this;\n\n      return _catch$1(function () {\n        // Perform the query\n        var promiseOrValue = fn.apply(void 0, _this6.config.queryFnParamsFilter(args));\n\n        _this6.cancelPromises = function () {\n          var _ref;\n\n          return (_ref = promiseOrValue) == null ? void 0 : _ref.cancel == null ? void 0 : _ref.cancel();\n        };\n\n        return _await(promiseOrValue, function (data) {\n          delete _this6.shouldContinueRetryOnFocus;\n          delete _this6.cancelPromises;\n          if (_this6.cancelled) throw _this6.cancelled;\n          return data;\n        });\n      }, function (error) {\n        var _exit = false;\n        delete _this6.cancelPromises;\n        if (_this6.cancelled) throw _this6.cancelled; // Do we need to retry the request?\n\n        return _invoke(function () {\n          if (_this6.config.retry === true || _this6.state.failureCount < _this6.config.retry || typeof _this6.config.retry === 'function' && _this6.config.retry(_this6.state.failureCount, error)) {\n            // If we retry, increase the failureCount\n            _this6.dispatch({\n              type: ActionType.Failed\n            }); // Only retry if the document is visible\n\n\n            if (!isDocumentVisible()) {\n              // set this flag to continue retries on focus\n              _this6.shouldContinueRetryOnFocus = true; // Resolve a\n\n              _exit = true;\n              return new Promise(noop);\n            }\n\n            delete _this6.shouldContinueRetryOnFocus; // Determine the retryDelay\n\n            var delay = functionalUpdate(_this6.config.retryDelay, _this6.state.failureCount); // Return a new promise with the retry\n\n            _exit = true;\n            return _await(new Promise(function (resolve, reject) {\n              // Keep track of the retry timeout\n              _this6.retryTimeout = setTimeout(_async(function () {\n                return _this6.cancelled ? reject(_this6.cancelled) : _catch$1(function () {\n                  return _await(_this6.tryFetchData(fn, args), function (data) {\n                    if (_this6.cancelled) return reject(_this6.cancelled);\n                    resolve(data);\n                  });\n                }, function (error) {\n                  if (_this6.cancelled) return reject(_this6.cancelled);\n                  reject(error);\n                });\n              }), delay);\n            }));\n          }\n        }, function (_result) {\n          if (_exit) return _result;\n          throw error;\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.fetch = function fetch(options) {\n    try {\n      var _this8 = this;\n\n      var queryFn = _this8.config.queryFn;\n\n      if (!queryFn) {\n        return;\n      } // If we are already fetching, return current promise\n\n\n      if (_this8.promise) {\n        return _this8.promise;\n      }\n\n      if (_this8.config.infinite) {\n        var infiniteConfig = _this8.config;\n        var infiniteData = _this8.state.data;\n        var fetchMore = options == null ? void 0 : options.fetchMore;\n        var originalQueryFn = queryFn;\n        queryFn = _async(function () {\n          var _interrupt = false;\n          var data = [];\n          var pageVariables = _this8.pageVariables ? [].concat(_this8.pageVariables) : [];\n          var rebuiltPageVariables = [];\n          return _continue(_do(function () {\n            var args = pageVariables.shift();\n            return _invokeIgnored$1(function () {\n              if (!data.length) {\n                var _push3 = data.push; // the first page query doesn't need to be rebuilt\n\n                return _await(originalQueryFn.apply(void 0, args), function (_originalQueryFn) {\n                  _push3.call(data, _originalQueryFn);\n\n                  rebuiltPageVariables.push(args);\n                });\n              } else {\n                // get an up-to-date cursor based on the previous data set\n                var nextCursor = infiniteConfig.getFetchMore(data[data.length - 1], data); // break early if there's no next cursor\n                // otherwise we'll start from the beginning\n                // which will cause unwanted duplication\n\n                if (!nextCursor) {\n                  _interrupt = true;\n                  return;\n                }\n\n                var pageArgs = [].concat(args.slice(0, -1), [nextCursor]);\n                var _push4 = data.push;\n                return _await(originalQueryFn.apply(void 0, pageArgs), function (_originalQueryFn2) {\n                  _push4.call(data, _originalQueryFn2);\n\n                  rebuiltPageVariables.push(pageArgs);\n                });\n              }\n            });\n          }, function () {\n            return !_interrupt && !!pageVariables.length;\n          }), function () {\n            _this8.fetchMoreVariable = infiniteConfig.getFetchMore(data[data.length - 1], data);\n            _this8.state.canFetchMore = Boolean(_this8.fetchMoreVariable);\n            _this8.pageVariables = rebuiltPageVariables;\n            return data;\n          });\n        });\n\n        if (fetchMore) {\n          queryFn = _async(function () {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            return _finallyRethrows(function () {\n              var fetchMoreVariable = fetchMore.fetchMoreVariable,\n                  previous = fetchMore.previous;\n\n              _this8.setState(function (old) {\n                return _extends({}, old, {\n                  isFetchingMore: previous ? 'previous' : 'next'\n                });\n              });\n\n              var newArgs = [].concat(args, [fetchMoreVariable]);\n\n              if (_this8.pageVariables) {\n                _this8.pageVariables[previous ? 'unshift' : 'push'](newArgs);\n              } else {\n                _this8.pageVariables = [newArgs];\n              }\n\n              return _await(originalQueryFn.apply(void 0, newArgs), function (newData) {\n                var data;\n\n                if (!infiniteData) {\n                  data = [newData];\n                } else if (previous) {\n                  data = [newData].concat(infiniteData);\n                } else {\n                  data = [].concat(infiniteData, [newData]);\n                }\n\n                _this8.fetchMoreVariable = infiniteConfig.getFetchMore(newData, data);\n                _this8.state.canFetchMore = Boolean(_this8.fetchMoreVariable);\n                return data;\n              });\n            }, function (_wasThrown, _result3) {\n              _this8.setState(function (old) {\n                return _extends({}, old, {\n                  isFetchingMore: false\n                });\n              });\n\n              return _rethrow(_wasThrown, _result3);\n            });\n          });\n        }\n      }\n\n      _this8.promise = _async(function () {\n        // If there are any retries pending for this query, kill them\n        _this8.cancelled = null;\n        return _catch$1(function () {\n          // Set up the query refreshing state\n          _this8.dispatch({\n            type: ActionType.Fetch\n          }); // Try to get the data\n\n\n          return _await(_this8.tryFetchData(queryFn, _this8.queryKey), function (data) {\n            _this8.setData(function (old) {\n              return _this8.config.isDataEqual(old, data) ? old : data;\n            });\n\n            delete _this8.promise;\n            return data;\n          });\n        }, function (error) {\n          _this8.dispatch({\n            type: ActionType.Error,\n            cancelled: error === _this8.cancelled,\n            error: error\n          });\n\n          delete _this8.promise;\n\n          if (error !== _this8.cancelled) {\n            throw error;\n          }\n        });\n      })();\n      return _this8.promise;\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.fetchMore = function fetchMore(fetchMoreVariable, options) {\n    return this.fetch({\n      fetchMore: {\n        fetchMoreVariable: fetchMoreVariable != null ? fetchMoreVariable : this.fetchMoreVariable,\n        previous: (options == null ? void 0 : options.previous) || false\n      }\n    });\n  };\n\n  return Query;\n}();\n\nfunction getDefaultState(config) {\n  var _config$initialStale;\n\n  var initialData = typeof config.initialData === 'function' ? config.initialData() : config.initialData;\n  var hasInitialData = typeof initialData !== 'undefined';\n  var isStale = !config.enabled || (typeof config.initialStale === 'function' ? config.initialStale() : (_config$initialStale = config.initialStale) != null ? _config$initialStale : !hasInitialData);\n  var initialStatus = hasInitialData ? QueryStatus.Success : config.enabled ? QueryStatus.Loading : QueryStatus.Idle;\n  return _extends({}, getStatusProps(initialStatus), {\n    error: null,\n    isFetched: false,\n    isFetching: initialStatus === QueryStatus.Loading,\n    failureCount: 0,\n    isStale: isStale,\n    data: initialData,\n    updatedAt: hasInitialData ? Date.now() : 0\n  });\n}\n\nfunction queryReducer(state, action) {\n  switch (action.type) {\n    case ActionType.Failed:\n      return _extends({}, state, {\n        failureCount: state.failureCount + 1\n      });\n\n    case ActionType.MarkStale:\n      return _extends({}, state, {\n        isStale: true\n      });\n\n    case ActionType.Fetch:\n      var status = typeof state.data !== 'undefined' ? QueryStatus.Success : QueryStatus.Loading;\n      return _extends({}, state, getStatusProps(status), {\n        isFetching: true,\n        failureCount: 0\n      });\n\n    case ActionType.Success:\n      return _extends({}, state, getStatusProps(QueryStatus.Success), {\n        data: functionalUpdate(action.updater, state.data),\n        error: null,\n        isStale: action.isStale,\n        isFetched: true,\n        isFetching: false,\n        updatedAt: Date.now(),\n        failureCount: 0\n      });\n\n    case ActionType.Error:\n      return _extends({}, state, {\n        failureCount: state.failureCount + 1,\n        isFetched: true,\n        isFetching: false,\n        isStale: true\n      }, !action.cancelled && _extends({}, getStatusProps(QueryStatus.Error), {\n        error: action.error,\n        throwInErrorBoundary: true\n      }));\n\n    case ActionType.SetState:\n      return functionalUpdate(action.updater, state);\n\n    default:\n      return state;\n  }\n} // CLASS\n\n\nfunction _empty$2() {}\n\nfunction _awaitIgnored$2(value, direct) {\n  if (!direct) {\n    return value && value.then ? value.then(_empty$2) : Promise.resolve();\n  }\n}\n\nfunction _catch$2(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _invoke$1(body, then) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(then);\n  }\n\n  return then(result);\n}\n\nvar QueryCache = /*#__PURE__*/function () {\n  function QueryCache(config) {\n    this.config = config || {}; // A frozen cache does not add new queries to the cache\n\n    this.globalListeners = [];\n    this.configRef = this.config.defaultConfig ? {\n      current: {\n        shared: _extends({}, defaultConfigRef.current.shared, this.config.defaultConfig.shared),\n        queries: _extends({}, defaultConfigRef.current.queries, this.config.defaultConfig.queries),\n        mutations: _extends({}, defaultConfigRef.current.mutations, this.config.defaultConfig.mutations)\n      }\n    } : defaultConfigRef;\n    this.queries = {};\n    this.isFetching = 0;\n  }\n\n  var _proto = QueryCache.prototype;\n\n  _proto.notifyGlobalListeners = function notifyGlobalListeners(query) {\n    var _this = this;\n\n    this.isFetching = Object.values(this.queries).reduce(function (acc, query) {\n      return query.state.isFetching ? acc + 1 : acc;\n    }, 0);\n    this.globalListeners.forEach(function (d) {\n      return d(_this, query);\n    });\n  };\n\n  _proto.getDefaultConfig = function getDefaultConfig() {\n    return this.configRef.current;\n  };\n\n  _proto.subscribe = function subscribe(listener) {\n    var _this2 = this;\n\n    this.globalListeners.push(listener);\n    return function () {\n      _this2.globalListeners.splice(_this2.globalListeners.indexOf(listener), 1);\n    };\n  };\n\n  _proto.clear = function clear(options) {\n    Object.values(this.queries).forEach(function (query) {\n      return query.clear();\n    });\n    this.queries = {};\n\n    if (options == null ? void 0 : options.notify) {\n      this.notifyGlobalListeners();\n    }\n  };\n\n  _proto.getQueries = function getQueries(predicate, options) {\n    if (predicate === true) {\n      return Object.values(this.queries);\n    }\n\n    var predicateFn;\n\n    if (typeof predicate === 'function') {\n      predicateFn = predicate;\n    } else {\n      var _ref = this.configRef.current.queries.queryKeySerializerFn(predicate),\n          queryHash = _ref[0],\n          _queryKey = _ref[1];\n\n      predicateFn = function predicateFn(d) {\n        return (options == null ? void 0 : options.exact) ? d.queryHash === queryHash : deepIncludes(d.queryKey, _queryKey);\n      };\n    }\n\n    return Object.values(this.queries).filter(predicateFn);\n  };\n\n  _proto.getQuery = function getQuery(predicate) {\n    return this.getQueries(predicate, {\n      exact: true\n    })[0];\n  };\n\n  _proto.getQueryData = function getQueryData(predicate) {\n    var _this$getQuery;\n\n    return (_this$getQuery = this.getQuery(predicate)) == null ? void 0 : _this$getQuery.state.data;\n  };\n\n  _proto.removeQueries = function removeQueries(predicate, options) {\n    this.getQueries(predicate, options).forEach(function (query) {\n      return query.clear();\n    });\n  };\n\n  _proto.cancelQueries = function cancelQueries(predicate, options) {\n    this.getQueries(predicate, options).forEach(function (query) {\n      return query.cancel();\n    });\n  };\n\n  _proto.invalidateQueries = function invalidateQueries(predicate, options) {\n    try {\n      var _this4 = this;\n\n      var _ref2 = options || {},\n          _ref2$refetchActive = _ref2.refetchActive,\n          refetchActive = _ref2$refetchActive === void 0 ? true : _ref2$refetchActive,\n          _ref2$refetchInactive = _ref2.refetchInactive,\n          refetchInactive = _ref2$refetchInactive === void 0 ? false : _ref2$refetchInactive,\n          throwOnError = _ref2.throwOnError;\n\n      return _catch$2(function () {\n        return _awaitIgnored$2(Promise.all(_this4.getQueries(predicate, options).map(function (query) {\n          if (query.instances.length) {\n            if (refetchActive && query.instances.some(function (instance) {\n              return instance.config.enabled;\n            })) {\n              return query.fetch();\n            }\n          } else {\n            if (refetchInactive) {\n              return query.fetch();\n            }\n          }\n\n          return query.invalidate();\n        })));\n      }, function (err) {\n        if (throwOnError) {\n          throw err;\n        }\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.resetErrorBoundaries = function resetErrorBoundaries() {\n    this.getQueries(true).forEach(function (query) {\n      query.state.throwInErrorBoundary = false;\n    });\n  };\n\n  _proto.buildQuery = function buildQuery(userQueryKey, queryConfig) {\n    var _this5 = this;\n\n    if (queryConfig === void 0) {\n      queryConfig = {};\n    }\n\n    var config = _extends({}, this.configRef.current.shared, this.configRef.current.queries, queryConfig);\n\n    var _ref3 = config.queryKeySerializerFn(userQueryKey),\n        queryHash = _ref3[0],\n        queryKey = _ref3[1];\n\n    var query;\n\n    if (this.queries[queryHash]) {\n      query = this.queries[queryHash];\n      query.config = config;\n    }\n\n    if (!query) {\n      query = new Query({\n        queryCache: this,\n        queryKey: queryKey,\n        queryHash: queryHash,\n        config: config,\n        notifyGlobalListeners: function notifyGlobalListeners(query) {\n          _this5.notifyGlobalListeners(query);\n        }\n      }); // If the query started with data, schedule\n      // a stale timeout\n\n      if (!isServer && query.state.data) {\n        query.scheduleStaleTimeout(); // Simulate a query healing process\n\n        query.heal(); // Schedule for garbage collection in case\n        // nothing subscribes to this query\n\n        query.scheduleGarbageCollection();\n      }\n\n      if (!this.config.frozen) {\n        this.queries[queryHash] = query;\n\n        if (isServer) {\n          this.notifyGlobalListeners();\n        } else {\n          // Here, we setTimeout so as to not trigger\n          // any setState's in parent components in the\n          // middle of the render phase.\n          setTimeout(function () {\n            _this5.notifyGlobalListeners();\n          });\n        }\n      }\n    }\n\n    return query;\n  } // Parameter syntax with optional prefetch options\n  ; // Implementation\n\n\n  _proto.prefetchQuery = function prefetchQuery() {\n    try {\n      var _this7 = this;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (isObject(args[1]) && (args[1].hasOwnProperty('throwOnError') || args[1].hasOwnProperty('force'))) {\n        args[3] = args[1];\n        args[1] = undefined;\n        args[2] = undefined;\n      }\n\n      var _getQueryArgs = getQueryArgs(args),\n          _queryKey2 = _getQueryArgs[0],\n          _config = _getQueryArgs[1],\n          _options = _getQueryArgs[2]; // https://github.com/tannerlinsley/react-query/issues/652\n\n\n      var configWithoutRetry = _extends({\n        retry: false\n      }, _config);\n\n      return _catch$2(function () {\n        var query = _this7.buildQuery(_queryKey2, configWithoutRetry);\n\n        return _invoke$1(function () {\n          if ((_options == null ? void 0 : _options.force) || query.state.isStale) {\n            return _awaitIgnored$2(query.fetch());\n          }\n        }, function () {\n          return query.state.data;\n        });\n      }, function (err) {\n        if (_options == null ? void 0 : _options.throwOnError) {\n          throw err;\n        }\n\n        Console.error(err);\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.setQueryData = function setQueryData(queryKey, updater, config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    var query = this.getQuery(queryKey);\n\n    if (!query) {\n      query = this.buildQuery(queryKey, config);\n    }\n\n    query.setData(updater);\n  };\n\n  return QueryCache;\n}();\n\nvar defaultQueryCache = makeQueryCache({\n  frozen: isServer\n});\nexports.queryCache = defaultQueryCache;\nvar queryCaches = [defaultQueryCache];\nexports.queryCaches = queryCaches;\n\nfunction makeQueryCache(config) {\n  return new QueryCache(config);\n}\n\nvar visibilityChangeEvent = 'visibilitychange';\nvar focusEvent = 'focus';\n\nvar onWindowFocus = function onWindowFocus() {\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(function (queryCache) {\n      return queryCache.invalidateQueries(function (query) {\n        if (!query.instances.length) {\n          return false;\n        }\n\n        if (!query.instances.some(function (instance) {\n          return instance.config.enabled;\n        })) {\n          return false;\n        }\n\n        if (!query.state.isStale) {\n          return false;\n        }\n\n        if (query.shouldContinueRetryOnFocus) {\n          // delete promise, so refetching will create new one\n          delete query.promise;\n        }\n\n        return Boolean(query.config.refetchOnWindowFocus);\n      }).catch(Console.error);\n    });\n  }\n};\n\nvar removePreviousHandler;\n\nfunction setFocusHandler(callback) {\n  // Unsub the old watcher\n  if (removePreviousHandler) {\n    removePreviousHandler();\n  } // Sub the new watcher\n\n\n  removePreviousHandler = callback(onWindowFocus);\n}\n\nsetFocusHandler(function (handleFocus) {\n  var _window; // Listen to visibillitychange and focus\n\n\n  if (!isServer && ((_window = window) == null ? void 0 : _window.addEventListener)) {\n    window.addEventListener(visibilityChangeEvent, handleFocus, false);\n    window.addEventListener(focusEvent, handleFocus, false);\n    return function () {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener(visibilityChangeEvent, handleFocus);\n      window.removeEventListener(focusEvent, handleFocus);\n    };\n  }\n\n  return;\n});\n\nvar queryCacheContext = _react.default.createContext(defaultQueryCache);\n\nvar useQueryCache = function useQueryCache() {\n  return _react.default.useContext(queryCacheContext);\n};\n\nexports.useQueryCache = useQueryCache;\n\nvar ReactQueryCacheProvider = function ReactQueryCacheProvider(_ref) {\n  var queryCache = _ref.queryCache,\n      children = _ref.children;\n\n  var resolvedQueryCache = _react.default.useMemo(function () {\n    return queryCache || makeQueryCache();\n  }, [queryCache]);\n\n  _react.default.useEffect(function () {\n    queryCaches.push(resolvedQueryCache);\n    return function () {\n      // remove the cache from the active list\n      var i = queryCaches.indexOf(resolvedQueryCache);\n\n      if (i > -1) {\n        queryCaches.splice(i, 1);\n      } // if the resolvedQueryCache was created by us, we need to tear it down\n\n\n      if (queryCache == null) {\n        resolvedQueryCache.clear({\n          notify: false\n        });\n      }\n    };\n  }, [resolvedQueryCache, queryCache]);\n\n  return /*#__PURE__*/_react.default.createElement(queryCacheContext.Provider, {\n    value: resolvedQueryCache\n  }, children);\n};\n\nexports.ReactQueryCacheProvider = ReactQueryCacheProvider;\n\nvar configContext = _react.default.createContext(undefined);\n\nfunction useConfigContext() {\n  var queryCache = useQueryCache();\n  return _react.default.useContext(configContext) || queryCache.getDefaultConfig() || defaultConfigRef.current;\n}\n\nvar ReactQueryConfigProvider = function ReactQueryConfigProvider(_ref) {\n  var config = _ref.config,\n      children = _ref.children;\n  var configContextValueOrDefault = useConfigContext();\n\n  var configContextValue = _react.default.useContext(configContext);\n\n  var newConfig = _react.default.useMemo(function () {\n    var _config$shared = config.shared,\n        shared = _config$shared === void 0 ? {} : _config$shared,\n        _config$queries = config.queries,\n        queries = _config$queries === void 0 ? {} : _config$queries,\n        _config$mutations = config.mutations,\n        mutations = _config$mutations === void 0 ? {} : _config$mutations;\n    var _configContextValueOr = configContextValueOrDefault.shared,\n        contextShared = _configContextValueOr === void 0 ? {} : _configContextValueOr,\n        _configContextValueOr2 = configContextValueOrDefault.queries,\n        contextQueries = _configContextValueOr2 === void 0 ? {} : _configContextValueOr2,\n        _configContextValueOr3 = configContextValueOrDefault.mutations,\n        contextMutations = _configContextValueOr3 === void 0 ? {} : _configContextValueOr3;\n    return {\n      shared: _extends({}, contextShared, shared),\n      queries: _extends({}, contextQueries, queries),\n      mutations: _extends({}, contextMutations, mutations)\n    };\n  }, [config, configContextValueOrDefault]);\n\n  _react.default.useEffect(function () {\n    // restore previous config on unmount\n    return function () {\n      defaultConfigRef.current = _extends({}, configContextValueOrDefault || DEFAULT_CONFIG);\n    };\n  }, [configContextValueOrDefault]); // If this is the outermost provider, overwrite the shared default config\n\n\n  if (!configContextValue) {\n    defaultConfigRef.current = newConfig;\n  }\n\n  return /*#__PURE__*/_react.default.createElement(configContext.Provider, {\n    value: newConfig\n  }, children);\n};\n\nexports.ReactQueryConfigProvider = ReactQueryConfigProvider;\n\nfunction useGetLatest(obj) {\n  var ref = _react.default.useRef(obj);\n\n  ref.current = obj;\n  return _react.default.useCallback(function () {\n    return ref.current;\n  }, []);\n}\n\nfunction useMountedCallback(callback) {\n  var mounted = _react.default.useRef(false);\n\n  _react.default[isServer ? 'useEffect' : 'useLayoutEffect'](function () {\n    mounted.current = true;\n    return function () {\n      mounted.current = false;\n    };\n  }, []);\n\n  return _react.default.useCallback(function () {\n    return mounted.current ? callback.apply(void 0, arguments) : void 0;\n  }, [callback]);\n}\n\nfunction useRerenderer() {\n  var rerender = useMountedCallback(_react.default.useState()[1]);\n  return _react.default.useCallback(function () {\n    return rerender({});\n  }, [rerender]);\n}\n\nfunction handleSuspense(config, result) {\n  var error = result.error,\n      query = result.query;\n  var state = query.state;\n\n  if (config.suspense || config.useErrorBoundary) {\n    if (state.status === QueryStatus.Error && state.throwInErrorBoundary) {\n      throw error;\n    }\n\n    if (config.suspense && state.status !== QueryStatus.Success && config.enabled) {\n      var instance = query.subscribe();\n      instance.updateConfig(_extends({}, config, {\n        onSettled: function onSettled(data, error) {\n          instance.unsubscribe(true);\n          config.onSettled == null ? void 0 : config.onSettled(data, error);\n        }\n      }));\n      throw query.fetch();\n    }\n  }\n}\n\nfunction useIsFetching() {\n  var queryCache = useQueryCache();\n  var rerender = useRerenderer();\n  var isFetching = queryCache.isFetching;\n  var getIsFetching = useGetLatest(isFetching);\n\n  _react.default.useEffect(function () {\n    return queryCache.subscribe(function (newCache) {\n      if (getIsFetching() !== newCache.isFetching) {\n        rerender();\n      }\n    });\n  }, [getIsFetching, queryCache, rerender]);\n\n  return isFetching;\n}\n\nfunction _await$1(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nvar ActionType$1;\n\nfunction _catch$3(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _async$1(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\n(function (ActionType) {\n  ActionType[\"Reset\"] = \"Reset\";\n  ActionType[\"Loading\"] = \"Loading\";\n  ActionType[\"Resolve\"] = \"Resolve\";\n  ActionType[\"Reject\"] = \"Reject\";\n})(ActionType$1 || (ActionType$1 = {})); // HOOK\n\n\nvar getDefaultState$1 = function getDefaultState() {\n  return _extends({}, getStatusProps(QueryStatus.Idle), {\n    data: undefined,\n    error: null\n  });\n};\n\nfunction mutationReducer(state, action) {\n  switch (action.type) {\n    case ActionType$1.Reset:\n      return getDefaultState$1();\n\n    case ActionType$1.Loading:\n      return _extends({}, getStatusProps(QueryStatus.Loading), {\n        data: undefined,\n        error: null\n      });\n\n    case ActionType$1.Resolve:\n      return _extends({}, getStatusProps(QueryStatus.Success), {\n        data: action.data,\n        error: null\n      });\n\n    case ActionType$1.Reject:\n      return _extends({}, getStatusProps(QueryStatus.Error), {\n        data: undefined,\n        error: action.error\n      });\n\n    default:\n      return state;\n  }\n}\n\nfunction useMutation(mutationFn, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _React$useReducer = _react.default.useReducer(mutationReducer, null, getDefaultState$1),\n      state = _React$useReducer[0],\n      unsafeDispatch = _React$useReducer[1];\n\n  var dispatch = useMountedCallback(unsafeDispatch);\n  var getMutationFn = useGetLatest(mutationFn);\n  var contextConfig = useConfigContext();\n  var getConfig = useGetLatest(_extends({}, contextConfig.shared, contextConfig.mutations, config));\n\n  var latestMutationRef = _react.default.useRef();\n\n  var mutate = _react.default.useCallback(_async$1(function (variables, mutateConfig) {\n    if (mutateConfig === void 0) {\n      mutateConfig = {};\n    }\n\n    var config = getConfig();\n    var mutationId = uid();\n    latestMutationRef.current = mutationId;\n\n    var isLatest = function isLatest() {\n      return latestMutationRef.current === mutationId;\n    };\n\n    var snapshotValue;\n    return _catch$3(function () {\n      dispatch({\n        type: ActionType$1.Loading\n      });\n      return _await$1(config.onMutate == null ? void 0 : config.onMutate(variables), function (_config$onMutate) {\n        snapshotValue = _config$onMutate;\n        return _await$1(getMutationFn()(variables), function (data) {\n          if (isLatest()) {\n            dispatch({\n              type: ActionType$1.Resolve,\n              data: data\n            });\n          }\n\n          return _await$1(config.onSuccess == null ? void 0 : config.onSuccess(data, variables), function () {\n            return _await$1(mutateConfig.onSuccess == null ? void 0 : mutateConfig.onSuccess(data, variables), function () {\n              return _await$1(config.onSettled == null ? void 0 : config.onSettled(data, null, variables), function () {\n                return _await$1(mutateConfig.onSettled == null ? void 0 : mutateConfig.onSettled(data, null, variables), function () {\n                  return data;\n                });\n              });\n            });\n          });\n        });\n      });\n    }, function (error) {\n      Console.error(error);\n      return _await$1(config.onError == null ? void 0 : config.onError(error, variables, snapshotValue), function () {\n        return _await$1(mutateConfig.onError == null ? void 0 : mutateConfig.onError(error, variables, snapshotValue), function () {\n          return _await$1(config.onSettled == null ? void 0 : config.onSettled(undefined, error, variables, snapshotValue), function () {\n            return _await$1(mutateConfig.onSettled == null ? void 0 : mutateConfig.onSettled(undefined, error, variables, snapshotValue), function () {\n              var _mutateConfig$throwOn;\n\n              if (isLatest()) {\n                dispatch({\n                  type: ActionType$1.Reject,\n                  error: error\n                });\n              }\n\n              if ((_mutateConfig$throwOn = mutateConfig.throwOnError) != null ? _mutateConfig$throwOn : config.throwOnError) {\n                throw error;\n              }\n            });\n          });\n        });\n      });\n    });\n  }), [dispatch, getConfig, getMutationFn]);\n\n  var reset = _react.default.useCallback(function () {\n    dispatch({\n      type: ActionType$1.Reset\n    });\n  }, [dispatch]);\n\n  _react.default.useEffect(function () {\n    var _getConfig = getConfig(),\n        suspense = _getConfig.suspense,\n        useErrorBoundary = _getConfig.useErrorBoundary;\n\n    if ((useErrorBoundary != null ? useErrorBoundary : suspense) && state.error) {\n      throw state.error;\n    }\n  }, [getConfig, state.error]);\n\n  return [mutate, _extends({}, state, {\n    reset: reset\n  })];\n}\n\nfunction useBaseQuery(queryKey, config) {\n  if (config === void 0) {\n    config = {};\n  } // Make a rerender function\n\n\n  var rerender = useRerenderer(); // Get the query cache\n\n  var queryCache = useQueryCache(); // Build the query for use\n\n  var query = queryCache.buildQuery(queryKey, config);\n  var state = query.state; // Create a query instance ref\n\n  var instanceRef = _react.default.useRef(); // Subscribe to the query when the subscribe function changes\n\n\n  _react.default.useEffect(function () {\n    var instance = query.subscribe(function () {\n      rerender();\n    });\n    instanceRef.current = instance; // Unsubscribe when things change\n\n    return function () {\n      return instance.unsubscribe();\n    };\n  }, [query, rerender]); // Always update the config\n\n\n  _react.default.useEffect(function () {\n    var _instanceRef$current;\n\n    (_instanceRef$current = instanceRef.current) == null ? void 0 : _instanceRef$current.updateConfig(config);\n  });\n\n  var enabledBool = Boolean(config.enabled); // Run the instance when the query or enabled change\n\n  _react.default.useEffect(function () {\n    var _instanceRef$current2;\n\n    (_instanceRef$current2 = instanceRef.current) == null ? void 0 : _instanceRef$current2.run();\n  }, [enabledBool, query]);\n\n  var clear = _react.default.useMemo(function () {\n    return query.clear.bind(query);\n  }, [query]);\n\n  var refetch = _react.default.useMemo(function () {\n    return query.refetch.bind(query);\n  }, [query]);\n\n  return {\n    clear: clear,\n    error: state.error,\n    failureCount: state.failureCount,\n    isError: state.isError,\n    isFetching: state.isFetching,\n    isIdle: state.isIdle,\n    isLoading: state.isLoading,\n    isStale: state.isStale,\n    isSuccess: state.isSuccess,\n    query: query,\n    refetch: refetch,\n    status: state.status,\n    updatedAt: state.updatedAt\n  };\n}\n\nfunction useQueryArgs(args) {\n  var configContext = useConfigContext();\n\n  var _getQueryArgs = getQueryArgs(args),\n      queryKey = _getQueryArgs[0],\n      config = _getQueryArgs[1],\n      options = _getQueryArgs[2]; // Build the final config\n\n\n  var configWithContext = _extends({}, configContext.shared, configContext.queries, config);\n\n  return [queryKey, configWithContext, options];\n} // Implementation\n\n\nfunction useQuery() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var _useQueryArgs = useQueryArgs(args),\n      queryKey = _useQueryArgs[0],\n      config = _useQueryArgs[1];\n\n  var result = useBaseQuery(queryKey, config);\n  handleSuspense(config, result);\n  return _extends({}, result, {\n    data: result.query.state.data\n  });\n} // as the query key changes, we keep the results from the\n// last query and use them as placeholder data in the next one\n// We DON'T use it as initial data though. That's important\n// TYPES\n// Implementation\n\n\nfunction usePaginatedQuery() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var _useQueryArgs = useQueryArgs(args),\n      queryKey = _useQueryArgs[0],\n      config = _useQueryArgs[1]; // Keep track of the latest data result\n\n\n  var lastDataRef = _react.default.useRef(); // If latestData is there, don't use initialData\n\n\n  if (typeof lastDataRef.current !== 'undefined') {\n    delete config.initialData;\n  } // Make the query as normal\n\n\n  var result = useBaseQuery(queryKey, config); // If the query is disabled, get rid of the latest data\n\n  if (!result.query.config.enabled) {\n    lastDataRef.current = undefined;\n  } // Get the real data and status from the query\n\n\n  var _result$query$state = result.query.state,\n      latestData = _result$query$state.data,\n      status = _result$query$state.status; // If the real query succeeds, and there is data in it,\n  // update the latest data\n\n  _react.default.useEffect(function () {\n    if (status === QueryStatus.Success && typeof latestData !== 'undefined') {\n      lastDataRef.current = latestData;\n    }\n  }, [latestData, status]); // Resolved data should be either the real data we're waiting on\n  // or the latest placeholder data\n\n\n  var resolvedData = latestData;\n\n  if (typeof resolvedData === 'undefined') {\n    resolvedData = lastDataRef.current;\n  } // If we have any data at all from either, we\n  // need to make sure the status is success, even though\n  // the real query may still be loading\n\n\n  if (typeof resolvedData !== 'undefined') {\n    var overrides = getStatusProps(QueryStatus.Success);\n    Object.assign(result.query.state, overrides);\n    Object.assign(result, overrides);\n  }\n\n  handleSuspense(config, result);\n  return _extends({}, result, {\n    resolvedData: resolvedData,\n    latestData: latestData\n  });\n} // Implementation\n\n\nfunction useInfiniteQuery() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var _useQueryArgs = useQueryArgs(args),\n      queryKey = _useQueryArgs[0],\n      config = _useQueryArgs[1];\n\n  config.infinite = true;\n  var result = useBaseQuery(queryKey, config);\n  var query = result.query;\n  var state = result.query.state;\n  handleSuspense(config, result);\n\n  var fetchMore = _react.default.useMemo(function () {\n    return query.fetchMore.bind(query);\n  }, [query]);\n\n  return _extends({}, result, {\n    data: state.data,\n    canFetchMore: state.canFetchMore,\n    fetchMore: fetchMore,\n    isFetching: state.isFetching,\n    isFetchingMore: state.isFetchingMore\n  });\n}"},"sourceMaps":null,"error":null,"hash":"e57fa9737826da4bd945905cf36e929c","cacheData":{"env":{}}}